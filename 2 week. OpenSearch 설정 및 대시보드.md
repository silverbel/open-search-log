# OpenSearch 도메인 생성

도메인을 생성할때 데이터 노드의 스펙을 설정하게 되는데, 데이터 노드에 대해서 무엇인지 알아보았습니다.

## 데이터 노드(Data Node)란?
OpenSearch에서 데이터 노드는 색인된 데이터를 저장하고, 검색 쿼리를 처리하는 핵심 노드입니다.

- 데이터를 디스크에 저장(Lucene 엔진 사용)
- 검색 쿼리를 처리하고 데이터를 반환
- 클러스터 내에서 샤드(Shard)를 호스팅하여 데이터를 분산 저장
즉, 데이터 노드는 DB의 저장소처럼 동작하지만, 검색 및 분석을 함께 수행하는 노드라고 보면 됩니다.


### 데이터 노드와 일반적인 DB와의 차이점
| 특징               | OpenSearch 데이터 노드               | 일반적인 DB (예: MySQL, PostgreSQL)     |
|--------------------|--------------------------------------|----------------------------------------|
| 데이터 저장 방식    | 샤드(Shard)로 분산 저장              | 테이블과 행(Row) 기반 저장            |
| 검색 속도           | Inverted Index 기반 검색             | SQL 기반 검색                         |
| 쿼리 방식           | OpenSearch DSL (예: match, term)     | SQL (SELECT, JOIN 등)                 |
| 확장성              | 여러 노드로 쉽게 확장 가능           | Scale-out이 어렵거나 제약이 있음      |

## OpenSearch 데이터노드의 샤드 저장방식

### 샤드(Shard)란?
- OpenSearch에서 데이터를 저장하는 가장 작은 단위입니다.
- 한 개의 인덱스(Index)는 여러 개의 샤드(Shard)로 구성될 수 있습니다.
- OpenSearch는 데이터를 여러 개의 샤드로 나누어 분산 저장하고 검색 속도를 최적화합니다.

📌 샤드를 쓰는 이유?
- 데이터 크기가 너무 커지면 한 개의 서버(노드)에 저장하기 어려움
- 검색 속도를 빠르게 하기 위해 여러 노드에서 동시에 검색 가능
- 하나의 서버에 장애가 발생해도 다른 서버에서 데이터 복구 가능 (Replica Shard 사용)

### 샤드 저장 방식 (분산 저장 구조 예시)
| 문서 ID | 샤드(Shard) ID |
|---------|----------------|
| Doc 1   | Shard 0        |
| Doc 2   | Shard 1        |
| Doc 3   | Shard 0        |
| Doc 4   | Shard 1        |
| Doc 5   | Shard 0        |
> Shard 0에는 Doc 1, Doc 3, Doc 5가 저장됨  
> Shard 1에는 Doc 2, Doc 4가 저장됨

### Primary Shard와 Replica Shard
**Primary Shard**와 **Replica Shard** 두 가지 종류가 있습니다.

**Primary Shard**
- 데이터를 최초로 저장하는 원본 샤드
- 인덱스 생성 시 고정 개수로 설정 (나중에 변경 불가)
- 기본적으로 모든 데이터를 저장하는 역할

**Replica Shard**
- Primary Shard의 백업 역할 (데이터 중복 저장)
- Primary Shard에 장애가 발생하면 Replica Shard가 대신 역할 수행
- 검색 요청 시 부하 분산 역할도 수행 (검색 속도 향상)

### Primary Shard와 Replica Shard를 사용하는 이유를 예제를 들어 알아봅시다!
| 샤드 타입         | 노드 1 | 노드 2 | 노드 3 |
|-------------------|--------|--------|--------|
| Primary Shard 0   | ✅     | ❌     | ❌     |
| Primary Shard 1   | ❌     | ✅     | ❌     |
| Replica Shard 0   | ❌     | ❌     | ✅     |
| Replica Shard 1   | ❌     | ✅     | ✅     |

- 데이터가 각 노드에 분산 저장되어 빠른 검색 가능
- 한 개의 노드가 장애가 나도 다른 노드가 데이터를 유지
➡ 안정성 + 속도 최적화 효과!

### 샤드 개수를 설정할 때 주의할 점
- 샤드 개수는 너무 적어도, 너무 많아도 안 좋음!
- 너무 적으면? 데이터가 한 노드에 집중되어 장애 발생 위험 증가
- 너무 많으면? 불필요한 리소스 낭비로 성능 저하

샤드 개수 설정 가이드 (gpt 버전..)
- 데이터 크기가 작으면 1~3개 샤드로 설정
- 데이터 크기가 크면 5~10개 샤드로 설정 (대규모 데이터는 20+ 가능)
- Replica Shard 개수를 최소 1개 이상 설정하여 안정성 유지

> Replica Shard 갯수는 나중에 수정가능하나 **Primary Shard는 나중에 수정이 불가**하여 초기 설계가 중요!!

## Inverted Index 기반 검색이란?
단어(토큰) 단위로 색인을 생성하여 빠르게 검색할 수 있도록 만든 구조입니다.
```json
GET users/_search
{
  "query": {
    "match": {
      "name": "John"
    }
  }
}
```
- OpenSearch는 name 필드에서 'John'이라는 단어(토큰)가 포함된 모든 문서를 빠르게 찾음
- 문서 기반 검색이며, 부분 검색, 유사 검색(예: "John Doe") 등이 가능합니다.

Inverted Index는 각 단어(토큰) 기준으로 색인을 생성합니다
| 단어       | 문서 ID 리스트 |
|------------|----------------|
| Elasticsearch | 1, 3           |
| OpenSearch    | 3              |
| search        | 1, 2           |
| engine        | 1, 2           |
| eun      | 1              |
| silverbell           | 2              |
| fast          | 2              |
| lookup        | 2              |
"search"라는 단어가 포함된 모든 문서(1, 2)를 바로 찾을 수 있습니다.


### Inverted Index의 장점과 단점
장점
- 검색 속도 극대화: 검색 시 문서 전체를 조회하지 않고 단어(토큰) 기반으로 빠르게 검색
- 부분 검색 가능: "search engine"을 검색하면 "powerful search engine"도 찾을 수 있음
- 유사 검색 가능: "OpenSearch"를 검색하면 "Elasticsearch"도 유사 검색 가능 (예: 동의어 처리)

단점
- 색인 크기가 커질 수 있음: 모든 단어(토큰)마다 별도 저장되므로 데이터 크기가 커질 수 있음
- 실시간 업데이트 성능이 떨어짐: 문서가 추가될 때마다 Inverted Index를 업데이트해야 하므로 느릴 수 있음

## 데이터 노드에서 사용할 수 있는 인스턴스 패밀리
| 인스턴스 패밀리  | CPU 유형         | 특징                                | 적합한 워크로드           |
|------------------|------------------|-------------------------------------|---------------------------|
| R6g, R7g         | AWS Graviton     | 고성능 메모리 최적화, 저전력        | 대규모 인덱스, 분석       |
| R5, R6i, R7i     | Intel Xeon       | 전통적인 메모리 최적화              | 다양한 검색 및 분석      |
| I3, I4i          | Intel Xeon       | 로컬 NVMe SSD 제공                  | 고속 색인, 높은 IOPS 필요 |
| M5, M6i, M7i     | Intel Xeon       | 균형 잡힌 성능                      | 일반적인 검색 및 분석    |
| C5, C6i, C7i     | Intel Xeon       | 고성능 컴퓨팅 최적화                | 복잡한 분석, ML          |
| T3, T4g          | Intel/Graviton   | 저렴한 버스트 가능 성능            | 작은 규모의 검색         |

> 테스트용으로 사용할것이기 때문에 m7g.medium.search(general purpose)를 채택!
